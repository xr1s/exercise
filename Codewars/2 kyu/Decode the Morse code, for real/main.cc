#include <igloo/igloo_alt.h>

#pragma push_macro("It")
#undef It
#include <algorithm>
#include <functional>
#include <string>
#include <vector>

#include <fmt/core.h>
#include <fmt/ranges.h>

#include <range/v3/all.hpp>
#pragma pop_macro("It")

std::map<std::string, std::string> morse_code = {
    {"-", "T"},      {"--", "M"},     {"---", "O"},         {"-----", "0"},
    {"----.", "9"},  {"---..", "8"},  {"---...", ":"},      {"--.", "G"},
    {"--.-", "Q"},   {"--..", "Z"},   {"--..--", ","},      {"--...", "7"},
    {"-.", "N"},     {"-.-", "K"},    {"-.--", "Y"},        {"-.--.", "{"},
    {"-.--.-", "}"}, {"-.-.", "C"},   {"-.-.--", "!"},      {"-.-.-.", ";"},
    {"-..", "D"},    {"-..-", "X"},   {"-..-.", "/"},       {"-...", "B"},
    {"-...-", "="},  {"-....", "6"},  {"-....-", "-"},      {".", "E"},
    {".-", "A"},     {".--", "W"},    {".---", "J"},        {".----", "1"},
    {".----.", "'"}, {".--.", "P"},   {".--.-.", "@"},      {".-.", "R"},
    {".-.-.", "+"},  {".-.-.-", "."}, {".-..", "L"},        {".-..-.", "\""},
    {".-...", "&"},  {"..", "I"},     {"..-", "U"},         {"..---", "2"},
    {"..--.-", "_"}, {"..--..", "?"}, {"..-.", "F"},        {"...", "S"},
    {"...-", "V"},   {"...--", "3"},  {"...---...", "SOS"}, {"...-..-", "$"},
    {"....", "H"},   {"....-", "4"},  {".....", "5"},
};

std::string decodeBitsAdvanced(const std::string bits) {
  auto bits_view =
      bits | ranges::views::trim([](const auto &c) { return c == '0'; });
  if (bits_view.size() == 0) return "";
  auto groups = bits_view | ranges::views::group_by(std::equal_to{});
  const auto group_len_of = [&groups](const auto &chars) {
    return groups | ranges::views::filter([&](const auto &group) {
             return group.front() == chars;
           })
        | ranges::views::transform(ranges::distance) | ranges::to<std::vector>;
  };
  const auto len0 = group_len_of('0'), len1 = group_len_of('1');
  const auto mlen1 = ranges::min(len1);
  const auto mlen0 = len0.size() != 0 ? ranges::min(len0) : mlen1;
  const auto blen = ranges::max(len1) == std::min(mlen0, mlen1)
      ? ranges::max(len1)
      : ranges::max(len1) / 2.;
  return groups | ranges::views::transform([&](const auto &g) {
           using namespace std::literals::string_literals;
           if (g.size() >= std::max(blen * 2.3, 5.) && g.front() == '0')
             return " "s;
           if (g.size() > blen && g.front() == '1') return "-"s;
           if (g.size() > blen && g.front() == '0') return "/"s;
           if (g.size() <= blen && g.front() == '1') return "."s;
           return ""s;
         })
      | ranges::actions::join;
}

std::string decodeMorse(const std::string morse) {
  return morse | ranges::views::split(' ')
      | ranges::views::transform([](const auto &words) {
           return words | ranges::views::split('/')
               | ranges::views::transform([](const auto &chars) {
                    return morse_code[chars | ranges::to<std::string>];
                  });
         })
      | ranges::views::join(" ") | ranges::actions::join
      | ranges::to<std::string>;
}

using namespace igloo;
Describe (decode_the_morse_for_real) {
  It (Example_from_description) {
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "000000001101101001110000011000000111111010011111001111110000000000"
            "011101111111101111101111100000010110001111110000011111001110110000"
            "0100000")),
        Equals("HEY JUDE"));
  }

  It (Very_short_messages) {
    Assert::That(decodeMorse(decodeBitsAdvanced("")), Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("0")), Equals(""));
    Assert::That(
        decodeMorse(
            decodeBitsAdvanced("000000000000000000000000000000000000000000")),
        Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("1")), Equals("E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("101")), Equals("I"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1001")), Equals("EE"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10001")), Equals("EE"));
    Assert::That(decodeMorse(decodeBitsAdvanced("100001")), Equals("EE"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("100000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1000000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10000000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10111")), Equals("A"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1110111")), Equals("M"));
    Assert::That(decodeMorse(decodeBitsAdvanced("111000111")), Equals("I"));
  }

  It (Multiple_bits_per_dot) {
    Assert::That(decodeMorse(decodeBitsAdvanced("111")), Equals("E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1111111")), Equals("E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("110011")), Equals("I"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced("111110000011111")), Equals("I"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced("11111100111111")), Equals("M"));
  }

  It (Extra_zeros) {
    Assert::That(decodeMorse(decodeBitsAdvanced("01110")), Equals("E"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced("000000011100000")), Equals("E"));
  }

  It (Empty_message) {
    Assert::That(decodeMorse(decodeBitsAdvanced("")), Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("0")), Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("0000000000")), Equals(""));
  }

  It (Long_message) {
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "110011001100110000001100000011111100110011111100111111000000000000"
            "001100111111001111110011111100000011001100111111000000111111001100"
            "1100000011")),
        Equals("HEY JUDE"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "000000000001111111000000110100011101110000000011100000000000000000"
            "011111110111111000011011111000001111001111000111111000000010111000"
            "000111111100100011111001100000111111001011111000000000000001111111"
            "000011110101100000110001111100100000111111100011111100111111100000"
            "100011111100011111111000000011111111011100000000000000101100001111"
            "111101111000001111101111100111111100000000111110010110111110000000"
            "000001110111110111110111110000000100010011111000001111101111111100"
            "000011100111111000111110100000011000010010000000000000000001111111"
            "100111110111111000000100010010000111110000001000000001011111010000"
            "000000000111111000000111101000010011000000000011100000000000000011"
            "011111011110001000001000011111111100000000011111100111111000111011"
            "000001111110000110111110001111110000000000000000011111100001001100"
            "000111111011111110111111111000000011111100011111000010000000000000"
            "00000000000000000000000000000000000000000000000")),
        Equals("THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "111110000011111110000111111000001111111111111110000111111111111110"
            "000001111111111111111000011100000111111000000011110000000000000000"
            "111111111111110000001111100000111111111111111000000111100000111111"
            "111111111000011111111111111100000000000000000000000000000000000111"
            "111111111111100000000000000011110000001111100000111100000001111000"
            "000000000001111100000000000000000000000000000000000111111111111111"
            "000001111111111111110000111110000011111111111111000000000000000011"
            "111110000001111110000000111111111111110000000000000000111100000011"
            "111000000000000000111111111111111000001111110001111111111111110000"
            "111100000000000000001111111111111100000001111000001111111111111100"
            "000000000000000000000000000000000111111111111111000001111110000111"
            "110000001111100000000000000011111100001111111111111111000000111100"
            "000000000000111111111111111000011111111111111100001111111111111100"
            "000000000000011111000000011111111111111100000001111111111111111100"
            "000000000000001111111111111110000011111000000000000000000000000000"
            "000000000111100011111000000111111111111111100000111000000000000000"
            "111111111111111100000111111111111100000011111111111111110000000000"
            "000011111111111111100000011111000011111100000011111111111111110000"
            "000000000000000000000000000000111100000111111111111111000000111111"
            "111111111000011111111111111110000000000000011111100011110000111111"
            "111111000000000000000011111111111111000000111111111111111000000000"
            "000001100000111111111111111000001111111111111111000001111100000000"
            "000000011111100001111100001111110000000000000000000000000000000000"
            "111111111111111100011111111111111110000011111111111111110000000000"
            "000001111000001111100001111000001111111111111110000000000000001111"
            "110000000000000001110000001111111111111110001111000000000000000000"
            "000000000000000000111111111111111000000000000000111111100001111000"
            "001111110000011111100000000000000011111100000000000000000000000000"
            "000000000001111110001111111111111111000001111000000111111100000000"
            "000000111100001111111111111110000000000000111111111111110000011111"
            "111111111110000011111000011111000000000000000111111111111110000011"
            "111100000111111111111111110000111111111111111000000000000000000000"
            "000000000000000011111111111111110000011111100000111100000000000001"
            "111111111111110000011111111111111110000111111111111111100000000000"
            "000011111111111111000000111111111111111000001111000000000000000111"
            "111000001111111111111100000011100000111111111111111100000111110000"
            "11111111111111")),
        Equals("SOS! THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG."));
  }

  It (Operator_is_nervous_his_hand_is_shaking_Figure_out_what_his_message_is) {
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "000000000000000111111110000000111111111111000000000001111111110000"
            "011111111101000000001111111111110110000111111110111111111110000000"
            "000000000000111111111100001100011111111111110001110000000000011111"
            "111111100001111111111000011001111111111100000000001111111111110111"
            "000011100000000000000000011111111110101111111101100000000000000011"
            "111111111000011111111111100001000011111111111111000000000001111111"
            "110000000110000001110000000000000000000000000000111100011111000001"
            "111000000001111111111001111111111001111111111111000000000111100111"
            "110111111100000000000000000000001111111111100000000111110000000111"
            "110000000011111111111100000000011111000111111110000000001111111111"
            "100000110000000001111100000001110000000000111111111111110001110011"
            "111111110011111100000000000000000000011110001111111111000011111111"
            "111111001000000000011111111001111111101111111100000000111011111110"
            "001110000000010011111110000000011111111110000000001111000011111110"
            "000000000000111111111001111111101111111111000000000001111111100000"
            "011000000000000000000001111111010100000100000011111111000000000111"
            "110001111111110000001111111111100111111110011111111100000000110001"
            "111111100001110111111111111000011111000011111111000000000000111100"
            "111011100010001111111100000000011110000111111100101100011111111110"
            "000000000000000001111111111100000001000000000000000000111101111100"
            "000010000111011100000000000111111111000000111111111111001111111111"
            "110001111111110000011111111000000000000011101111111111110000001100"
            "111111111111011100011111111111000000001111000001111000001111111111"
            "000001111111111110000000111111110000000000010000001111000000010000"
            "011111001111111111100000000000000000000100011111111000000111111111"
            "000000000000001000011111111111101110011111111111000001111111000011"
            "111111110000000000000000000000000111000001111111111110111100000000"
            "100000000111111111000111111111111000011100001111111111111000000000"
            "000001111100000111110011111111000000000000111000111000000000000111"
            "110000011111111111010000000011100000000000000000000000000001111100"
            "100000000001111111110000111111111100000000001111111111111011111111"
            "111000000000100000000000000111111111001000011000000000000001111001"
            "111000000000011000000011111111111100000000111111111110000000001111"
            "000000000000000000001111011111111111110000000000011110000111110000"
            "111100000000011001111111001110000000001001110000000000001111100000"
            "100000111110000000000000011111111111000000001101111111111000000000"
            "000001111111111111000001110000000001111111100011110000001111111101"
            "111110000000011110000000000100001111111110000111100011111111101111"
            "100001111111111110000000000000000000000001111111111100000001110111"
            "111111000111111100000000011111111100000111111111001111111100000000"
            "011111111111001111111111100000000001100000000000000000010000111111"
            "111100000000011111111100000000000000000000000111111111111110000001"
            "111111110000011111111100000000001111111100000100000000111111110000"
            "111110011111111000000011100000000111100000000010111111110000111110"
            "111111111100110111111111110000000000000000001000111111111111011111"
            "111000000000000000011000000000000000000111100101111100000000111111"
            "111000000000011111000111111111111011000000001111100000111100001111"
            "111111110000000011111111111000011101111111111101110000000000111111"
            "111011111000111111111100000000000000000000000000100001111111111000"
            "000000011111111101111100000000000000000000001100000111100000000000"
            "011111111111001100011111111000000111000000000001111100000000111111"
            "111100000111110000011110001100000000111000000000000001111000011111"
            "111111000001110000000011111111110000001111111111001100000000011110"
            "000011111111000111000011111111100000100111111111100000000000000000"
            "001111000000111110000011110000000001111110011100000000111111110001"
            "000000000000111111110000110011111111000000000001101110000000000001"
            "111111111110001000000001111111111100000011111111110111000000000000"
            "00000000000000")),
        Equals("MGY CQD CQD SOS TITANIC POSITION 41.44 N 50.24 W. REQUIRE "
               "IMMEDIATE ASSISTANCE. COME AT ONCE. WE STRUCK AN ICEBERG. "
               "SINKING"));
  }
};

int main() {
  igloo::TestRunner::RunAllTests();
}

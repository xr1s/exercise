// kMeans 失败，最后一个个测试用例不管用那种平均数、中位数，始终收敛到同一个值。
// 正确答案应该在 <= 7 和 <= 17 处是两个分隔符。
#include <igloo/igloo_alt.h>

#include <functional>
#include <map>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include <fmt/core.h>
#include <fmt/ranges.h>

#pragma push_macro("It")
#undef It
#include <range/v3/all.hpp>
#pragma pop_macro("It")

std::map<std::string, std::string> morse_code = {
    {"-", "T"},      {"--", "M"},     {"---", "O"},         {"-----", "0"},
    {"----.", "9"},  {"---..", "8"},  {"---...", ":"},      {"--.", "G"},
    {"--.-", "Q"},   {"--..", "Z"},   {"--..--", ","},      {"--...", "7"},
    {"-.", "N"},     {"-.-", "K"},    {"-.--", "Y"},        {"-.--.", "{"},
    {"-.--.-", "}"}, {"-.-.", "C"},   {"-.-.--", "!"},      {"-.-.-.", ";"},
    {"-..", "D"},    {"-..-", "X"},   {"-..-.", "/"},       {"-...", "B"},
    {"-...-", "="},  {"-....", "6"},  {"-....-", "-"},      {".", "E"},
    {".-", "A"},     {".--", "W"},    {".---", "J"},        {".----", "1"},
    {".----.", "'"}, {".--.", "P"},   {".--.-.", "@"},      {".-.", "R"},
    {".-.-.", "+"},  {".-.-.-", "."}, {".-..", "L"},        {".-..-.", "\""},
    {".-...", "&"},  {"..", "I"},     {"..-", "U"},         {"..---", "2"},
    {"..--.-", "_"}, {"..--..", "?"}, {"..-.", "F"},        {"...", "S"},
    {"...-", "V"},   {"...--", "3"},  {"...---...", "SOS"}, {"...-..-", "$"},
    {"....", "H"},   {"....-", "4"},  {".....", "5"},
};

std::map<double, int> kMeans(
    const std::vector<double> &points,
    const std::map<int, double> &centroids) {
  // 按照点聚类
  const auto clusters =
      points | ranges::views::transform([&](const auto &point) {
        // 找到距离 point 最近的质心，并按最近质心进行聚合
        const auto nearest_centroid =
            ranges::min_element(centroids, {}, [&](const auto &centroid) {
              return std::abs(centroid.second - point);
            })->first;
        // 将点转化成 (centroid_id, point) 的形式便于排序聚合
        return std::pair{nearest_centroid, point};
      })
      | (ranges::to<std::multimap>);  // 为了在链式调用中排序，使用了 multimap
  const auto next =
      clusters | ranges::views::group_by([](const auto &lhs, const auto &rhs) {
        return lhs.first == rhs.first;  //  按照质心聚合
      })
      | ranges::views::transform([](const auto &cluster) {
          // 算数平均数
          static const auto second =
              ranges::views::transform(&std::pair<const int, double>::second);
          return std::pair{
              ranges::front(cluster).first,
              ranges::accumulate(cluster | second, 0.)
                  / ranges::distance(cluster)};
        })
      | ranges::to<std::map>;
  if (next != centroids) return kMeans(points, next);
  return clusters | ranges::views::transform([](const auto &point) {
           return std::pair{point.second, point.first};
         })
      | ranges::to<std::map>;
}

std::string decodeBitsAdvanced(const std::string bits) {
  fmt::print(stderr, "input = {}\n", bits);
  static const char *bitmap[2][3] = {{"", "/", " "}, {".", "-", "-"}};
  static const std::map<int, const char *> repr[2] = {
      {{1, ""}, {3, "/"}, {7, " "}}, {{1, "."}, {3, "-"}, {7, "-"}}};
  auto bits_view =
      bits | ranges::views::trim([](const auto &c) { return c == '0'; });
  if (bits_view.size() == 0) return "";
  const auto colors =
      bits_view | ranges::views::unique | ranges::to<std::string>();
  const auto splits = bits_view | ranges::views::group_by(std::equal_to{})
      | ranges::views::transform(ranges::distance)
      | ranges::to<std::vector<double>>();
  const auto [min, max] = ranges::minmax(splits);
  auto clusters = kMeans(splits, {{1, min}, {3, (min + max) / 2}, {7, max}});
  const auto almost_morse = ranges::views::ints(0UL, splits.size())
      | ranges::views::transform([&](const auto &index) {
                              return repr[colors[index] - '0']
                                  .find(clusters[splits[index]])
                                  ->second;
                            })
      | ranges::to<std::vector<std::string>>;
  return almost_morse | ranges::views::join | ranges::to<std::string>;
}

std::string decodeMorse(const std::string morse) {
  fmt::print(stderr, "morse = {}\n", morse);
  const auto sentence =
      morse | ranges::views::split(' ')
      | ranges::views::transform([](const auto &words) {
          return words | ranges::views::split('/')
              | ranges::views::transform([](const auto &chars) {
                   return morse_code[chars | ranges::to<std::string>];
                 });
        })
      | ranges::views::join(" ") | ranges::actions::join
      | ranges::to<std::string>;
  fmt::print(stderr, "outpt = {}\n\n", sentence);
  return sentence;
}

using namespace igloo;
Describe (decode_the_morse_for_real) {
  It (Example_from_description) {
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "000000001101101001110000011000000111111010011111001111110000000000"
            "011101111111101111101111100000010110001111110000011111001110110000"
            "0100000")),
        Equals("HEY JUDE"));
  }

  It (Very_short_messages) {
    Assert::That(decodeMorse(decodeBitsAdvanced("")), Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("0")), Equals(""));
    Assert::That(
        decodeMorse(
            decodeBitsAdvanced("000000000000000000000000000000000000000000")),
        Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("1")), Equals("E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("101")), Equals("I"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1001")), Equals("EE"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10001")), Equals("EE"));
    Assert::That(decodeMorse(decodeBitsAdvanced("100001")), Equals("EE"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("100000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1000000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10000000001")), Equals("E E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("10111")), Equals("A"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1110111")), Equals("M"));
    Assert::That(decodeMorse(decodeBitsAdvanced("111000111")), Equals("I"));
  }

  It (Multiple_bits_per_dot) {
    Assert::That(decodeMorse(decodeBitsAdvanced("111")), Equals("E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("1111111")), Equals("E"));
    Assert::That(decodeMorse(decodeBitsAdvanced("110011")), Equals("I"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced("111110000011111")), Equals("I"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced("11111100111111")), Equals("M"));
  }

  It (Extra_zeros) {
    Assert::That(decodeMorse(decodeBitsAdvanced("01110")), Equals("E"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced("000000011100000")), Equals("E"));
  }

  It (Empty_message) {
    Assert::That(decodeMorse(decodeBitsAdvanced("")), Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("0")), Equals(""));
    Assert::That(decodeMorse(decodeBitsAdvanced("0000000000")), Equals(""));
  }

  It (Long_message) {
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "110011001100110000001100000011111100110011111100111111000000000000"
            "001100111111001111110011111100000011001100111111000000111111001100"
            "1100000011")),
        Equals("HEY JUDE"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "000000000001111111000000110100011101110000000011100000000000000000"
            "011111110111111000011011111000001111001111000111111000000010111000"
            "000111111100100011111001100000111111001011111000000000000001111111"
            "000011110101100000110001111100100000111111100011111100111111100000"
            "100011111100011111111000000011111111011100000000000000101100001111"
            "111101111000001111101111100111111100000000111110010110111110000000"
            "000001110111110111110111110000000100010011111000001111101111111100"
            "000011100111111000111110100000011000010010000000000000000001111111"
            "100111110111111000000100010010000111110000001000000001011111010000"
            "000000000111111000000111101000010011000000000011100000000000000011"
            "011111011110001000001000011111111100000000011111100111111000111011"
            "000001111110000110111110001111110000000000000000011111100001001100"
            "000111111011111110111111111000000011111100011111000010000000000000"
            "00000000000000000000000000000000000000000000000")),
        Equals("THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG"));
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "111110000011111110000111111000001111111111111110000111111111111110"
            "000001111111111111111000011100000111111000000011110000000000000000"
            "111111111111110000001111100000111111111111111000000111100000111111"
            "111111111000011111111111111100000000000000000000000000000000000111"
            "111111111111100000000000000011110000001111100000111100000001111000"
            "000000000001111100000000000000000000000000000000000111111111111111"
            "000001111111111111110000111110000011111111111111000000000000000011"
            "111110000001111110000000111111111111110000000000000000111100000011"
            "111000000000000000111111111111111000001111110001111111111111110000"
            "111100000000000000001111111111111100000001111000001111111111111100"
            "000000000000000000000000000000000111111111111111000001111110000111"
            "110000001111100000000000000011111100001111111111111111000000111100"
            "000000000000111111111111111000011111111111111100001111111111111100"
            "000000000000011111000000011111111111111100000001111111111111111100"
            "000000000000001111111111111110000011111000000000000000000000000000"
            "000000000111100011111000000111111111111111100000111000000000000000"
            "111111111111111100000111111111111100000011111111111111110000000000"
            "000011111111111111100000011111000011111100000011111111111111110000"
            "000000000000000000000000000000111100000111111111111111000000111111"
            "111111111000011111111111111110000000000000011111100011110000111111"
            "111111000000000000000011111111111111000000111111111111111000000000"
            "000001100000111111111111111000001111111111111111000001111100000000"
            "000000011111100001111100001111110000000000000000000000000000000000"
            "111111111111111100011111111111111110000011111111111111110000000000"
            "000001111000001111100001111000001111111111111110000000000000001111"
            "110000000000000001110000001111111111111110001111000000000000000000"
            "000000000000000000111111111111111000000000000000111111100001111000"
            "001111110000011111100000000000000011111100000000000000000000000000"
            "000000000001111110001111111111111111000001111000000111111100000000"
            "000000111100001111111111111110000000000000111111111111110000011111"
            "111111111110000011111000011111000000000000000111111111111110000011"
            "111100000111111111111111110000111111111111111000000000000000000000"
            "000000000000000011111111111111110000011111100000111100000000000001"
            "111111111111110000011111111111111110000111111111111111100000000000"
            "000011111111111111000000111111111111111000001111000000000000000111"
            "111000001111111111111100000011100000111111111111111100000111110000"
            "11111111111111")),
        Equals("SOS! THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG."));
  }

  It (Operator_is_nervous_his_hand_is_shaking_Figure_out_what_his_message_is) {
    Assert::That(
        decodeMorse(decodeBitsAdvanced(
            "000000000000000111111110000000111111111111000000000001111111110000"
            "011111111101000000001111111111110110000111111110111111111110000000"
            "000000000000111111111100001100011111111111110001110000000000011111"
            "111111100001111111111000011001111111111100000000001111111111110111"
            "000011100000000000000000011111111110101111111101100000000000000011"
            "111111111000011111111111100001000011111111111111000000000001111111"
            "110000000110000001110000000000000000000000000000111100011111000001"
            "111000000001111111111001111111111001111111111111000000000111100111"
            "110111111100000000000000000000001111111111100000000111110000000111"
            "110000000011111111111100000000011111000111111110000000001111111111"
            "100000110000000001111100000001110000000000111111111111110001110011"
            "111111110011111100000000000000000000011110001111111111000011111111"
            "111111001000000000011111111001111111101111111100000000111011111110"
            "001110000000010011111110000000011111111110000000001111000011111110"
            "000000000000111111111001111111101111111111000000000001111111100000"
            "011000000000000000000001111111010100000100000011111111000000000111"
            "110001111111110000001111111111100111111110011111111100000000110001"
            "111111100001110111111111111000011111000011111111000000000000111100"
            "111011100010001111111100000000011110000111111100101100011111111110"
            "000000000000000001111111111100000001000000000000000000111101111100"
            "000010000111011100000000000111111111000000111111111111001111111111"
            "110001111111110000011111111000000000000011101111111111110000001100"
            "111111111111011100011111111111000000001111000001111000001111111111"
            "000001111111111110000000111111110000000000010000001111000000010000"
            "011111001111111111100000000000000000000100011111111000000111111111"
            "000000000000001000011111111111101110011111111111000001111111000011"
            "111111110000000000000000000000000111000001111111111110111100000000"
            "100000000111111111000111111111111000011100001111111111111000000000"
            "000001111100000111110011111111000000000000111000111000000000000111"
            "110000011111111111010000000011100000000000000000000000000001111100"
            "100000000001111111110000111111111100000000001111111111111011111111"
            "111000000000100000000000000111111111001000011000000000000001111001"
            "111000000000011000000011111111111100000000111111111110000000001111"
            "000000000000000000001111011111111111110000000000011110000111110000"
            "111100000000011001111111001110000000001001110000000000001111100000"
            "100000111110000000000000011111111111000000001101111111111000000000"
            "000001111111111111000001110000000001111111100011110000001111111101"
            "111110000000011110000000000100001111111110000111100011111111101111"
            "100001111111111110000000000000000000000001111111111100000001110111"
            "111111000111111100000000011111111100000111111111001111111100000000"
            "011111111111001111111111100000000001100000000000000000010000111111"
            "111100000000011111111100000000000000000000000111111111111110000001"
            "111111110000011111111100000000001111111100000100000000111111110000"
            "111110011111111000000011100000000111100000000010111111110000111110"
            "111111111100110111111111110000000000000000001000111111111111011111"
            "111000000000000000011000000000000000000111100101111100000000111111"
            "111000000000011111000111111111111011000000001111100000111100001111"
            "111111110000000011111111111000011101111111111101110000000000111111"
            "111011111000111111111100000000000000000000000000100001111111111000"
            "000000011111111101111100000000000000000000001100000111100000000000"
            "011111111111001100011111111000000111000000000001111100000000111111"
            "111100000111110000011110001100000000111000000000000001111000011111"
            "111111000001110000000011111111110000001111111111001100000000011110"
            "000011111111000111000011111111100000100111111111100000000000000000"
            "001111000000111110000011110000000001111110011100000000111111110001"
            "000000000000111111110000110011111111000000000001101110000000000001"
            "111111111110001000000001111111111100000011111111110111000000000000"
            "00000000000000")),
        Equals("MGY CQD CQD SOS TITANIC POSITION 41.44 N 50.24 W. REQUIRE "
               "IMMEDIATE ASSISTANCE. COME AT ONCE. WE STRUCK AN ICEBERG. "
               "SINKING"));
  }
};

int main() {
  igloo::TestRunner::RunAllTests();
}

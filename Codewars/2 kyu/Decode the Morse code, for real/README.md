# Decode the Morse code, for real

> 首先题目大意参考 [Decode the Morse code, advanced](../../4%20kyu/Decode%20the%20Morse%20code,%20advanced/README.md)
>
> 和 advanced 相比，就是说，不稳定了。（解释不清的样子，具体还是看题目）
>
> 重点在于：保证每个测试是稳定的，即如果对于连续的 n 个 1，如果答案中被映射到了 '-'；
>
> 那么对于同一个测试用例中的其它连续 n 个 1，都会被映射到 '-'，连续 n 个 0 都会被映射到字符中断。
>
> 对于 3 单位长的 '.' 和 7 单位长的 ' ' 同理。

所以题目其实变成了找分隔位置，一开始肯定是映射到 1 单位长度，从哪个位置开始都映射到 3 单位长度，从哪个位置开始都映射到 7 单位长度。

比较骚的就是，题目中说，如果你做不出来，可以试试这个，然后给出了一个链接向 K 聚类算法的链接。

但是实际上 K 聚类解决不了超短测试用例，还有最后一个测试用例（泰坦尼克号那条）。

超短测试用例是个败笔，它的可能答案很多，计算结果过于依赖初始状态和聚类算法。

泰坦尼克号则是不管初始簇选什么，聚类算法选什么，始终收敛到一个无解的状态。

我还试过枚举分隔位置，实际上答案太多也没法做。

所以大家的题解都不是用 K 聚类的，全都是用了好多魔法数字的。最后我从 Python 题解里抄了最优的。

为了证明我实际上在这题真的卡了一周毫无进展，绝望了才去看的答案，我把我的 K 聚类算法也发上来。

> 试写出下列语言的正则定义：
>
> 1）包含 5 个元音的小写字母串，这些串中的元音按顺序出现。  
> 2）所有由按词典递增序排列的小写字母组成的串。  
> 3）注释，即 `/*` 和 `*/` 之间的串，且串中没有不在双引号（`"`）中的 `*/`。  
> !! 4）所有不重复的数位组成的串。*提示*：首先尝试解决只含有少量数位（比如 `{0, 1, 2}`）的数位串。  
> !! 5）所有最多只有一个重复数位的串。  
> !! 6）所有由偶数个 a 和奇数个 b 构成的串。  
> 7）以非正式方式表示的国际象棋步法的集合，如 `p-k4` 或 `kbp×qn`。  
> !! 8）所有由 a 和 b 组成且不包含子串 abb 的串。  
> 9）所有由 a 和 b 组成且不含子序列 abb 的串。  

有些题因为太长所以用空格回车来分段了，自行无视空白字符即可。

### 1）包含 5 个元音的小写字母串，这些串中的元音按顺序出现。

定义 consonant `C = [bcdfghjklmnpqrstvwxyz]`；
```
C*
a(a|C)*
e(e|C)*
i(i|C)*
o(o|C)*
u(u|C)*
```

### 2）所有由按词典递增序排列的小写字母组成的串。
```
a*b*c*d*e*f*g*h*i*j*k*l*m*
n*o*p*q*r*s*t*u*v*w*x*y*z*
```

### 3）注释，即 `/*` 和 `*/` 之间的串，且串中没有不在双引号（`"`）中的 `*/`。

这什么屌题，题目都看不懂。

```
/\*
( "[^"]*"
| (\*)+
  ( "[^"]*"
  | [^*/]
  )
| [^*]
)*
(\*)+/
```

解释一下：  
第一行是 `/*`；  
第二行开始到第八行是注释内容，分三部分；  
第二行是第一部分，是被引号包围的处理，用来特殊处理被引号包围的 `*/`，`[^"]` 是单字符非贪婪匹配的一种实现方式；  
第三四五六行是第二部分，匹配星号，做这个处理是为了防止后续不匹配上 `/`，否则注释就闭合了；  
其中第四行第五行是因为需要向前看一个字符，会导致正则多吃一个字符，所以需要再把注释中可能出现的情况重新枚举了一下；  
第七行匹配任意其它字符，注释中本来就啥都可以写，除此外排除了后面只剩下 `*` 的特殊情况，这个在最后匹配；  
第八行表示注释内容中间的部分重复任意多次（包括为空）；  
第九行是注释的闭合 `*/`，`\*+` 是为了匹配最后都是 `*` 的特殊情况。

因为没有书中没有提供惰性模式的定义，所以这里也不使用惰性模式来解决 `/**/*/` 的问题，而是采用了比较崎岖的方法。

几个测试用例：
* 可以匹配：`/**/` `/* comments */` `/***/` `/****/` `/*"*/` `/**"*/` `/*"*/"*/` `/***"*/"*/` `/*"/**/"*/` `/*/*/` `/***x*/`
* 无法匹配：`/*/` `/*"*/"` `/*""*/"*/` `/**/*/` `/***/*/`

备注一下，如果允许使用惰性模式，那就简单很多了：`/\*(".*?"|[^"]*?)\*/`

### !! 4）所有不重复的数位组成的串。*提示*：首先尝试解决只含有少量数位（比如 `{0, 1, 2}`）的数位串。

如果不允许使用负向先行断言会巨麻烦。

最简单的思路就是把已经有出现的字符作为当前状态；就算这样除开始和结束状态数也有 1024 个，有点太多了。（算法是考虑每个字符都有可能出现和不出现）。

如果像题目里解决只有少量数位那个只有 8 种状态还可以接受：`0?(12|21)?|1?(02|20)?|2?(01|10)?`；

如果允许负向先行断言和引用捕获组，可以参考这个 [StackOverflow 问题](https://stackoverflow.com/questions/20205653/regex-to-find-numbers-with-unique-digits)，答案可以是 `(?!.*(.).*\1)\d{,10}`。

解释一下：

`(?!regex)` 是零宽负向先行断言：  
零宽表示它匹配的是一对字符间的位置而非一个字符（它并不消耗字符）；  
负向表示该位置不能出现匹配的东西；  
先行表示从匹配位置向后找正则匹配；  
断言表示需要满足上述条件；  
合起来说，就是从这个位置往后的字符串，不能匹配上 regex 这个串表示的正则。  
出现在开头，就表示这整个字符串不能匹配上这个正则。

再来看零宽负向先行断言里的正则 `.*(.).*\1`：  
`.*` 表示匹配任意字符串；  
`(.)` 是一个捕获组，马上有用到；  
`.*` 表示匹配任意字符串，前面三个部分的含义是对于后续字符串中的任意字符；  
`\1` 是引用首个捕获组，引用的就是上面的那个 `(.)`，表示任意字符重复一次；  
那么这个断言的含义就很明确了，表示对于后续字符串中的任意字符，它们需要重复至少一次；  
因为它是个负向断言，因此它的真正含义是，对于后续字符串中的任意字符，它们不能重复。

剩下的就好说了，`\d{,10}` 表示只要匹配到 10 个数字即可。

### !! 5）所有最多只有一个重复数位的串。

如果允许零宽负向断言也很简单，直接沿用 4）的结论即可：`(?!.*(.).*\1.*\1)\d{,10}`。

如果用状态机来表达的话，那状态会多好几倍。因为需要额外储存一个某字符已经被匹配了一次的状态。

4）就已经 1024 个状态了，算了一下 5）要 6132 个状态，没想到怎么做。（算法是 `sum((k + 1) * C(10, k) for k in range(1, 10))`，其中 `C` 是组合数）。

### !! 6）所有由偶数个 a 和奇数个 b 构成的串。

这是一道很典型的题，用状态机来做是最佳选择。

我们有四种状态，包括 a 出现偶数次或奇数次，b 出现偶数次或奇数次，这 2\*2 种组合。

方便起见，下文用 `a0b0` 表示 a 偶 b 偶，`a0b1` 表示 a 偶 b 奇，`a1b0` 表示 a 奇 b 偶，`a1b1` 表示 a 奇 b 奇。

它们之间的状态转移也很清晰，就是多个 a 或者 b 的事情。开始节点显然是 `a0b0`，终结节点则根据题目要求是 `a0b1`。

然后开始消除状态，[详情见图](http://magjac.com/graphviz-visual-editor/?dot=digraph%20finite_state_machine%7Bsubgraph%20cluster_origin%7Blabel%3D%22%E5%88%9D%E5%A7%8B%22%3Bnode%5Bshape%3Ddoublecircle%5D%3Borigin_a0b0%20origin_a0b1%3Bnode%5Bshape%3Dcircle%2Cnodesep%3D3%5D%3B%7Brank%3Dsame%3Borigin_a0b0%5Blabel%3Da0b0%5D%3Borigin_a1b0%5Blabel%3Da1b0%5D%3B%7D%7Brank%3Dsame%3Borigin_a0b1%5Blabel%3Da0b1%5D%3Borigin_a1b1%5Blabel%3Da1b1%5D%3B%7Dorigin_a0b0-%3Eorigin_a1b0-%3Eorigin_a0b0%5Blabel%3Da%5D%3Borigin_a0b0-%3Eorigin_a0b1-%3Eorigin_a0b0%5Blabel%3Db%5D%3Borigin_a1b1-%3Eorigin_a0b1-%3Eorigin_a1b1%5Blabel%3Da%5D%3Borigin_a1b1%3Ane-%3Eorigin_a1b0%5Blabel%3Db%5D%3Borigin_a1b0-%3Eorigin_a1b1%5Blabel%3Db%5D%3B%7Dsubgraph%20cluster_first%7Blabel%3D%22%E6%B6%88%E5%8E%BBa1b0%22%3Bnode%5Bshape%3Ddoublecircle%5D%3Bfirst_a0b0%20first_a0b1%3Bnode%5Bshape%3Dcircle%5D%3Bfirst_a0b0%5Blabel%3Da0b0%5D%3B%7Brank%3Dsame%3Bfirst_a0b1%5Blabel%3Da0b1%5D%3Bfirst_a1b1%5Blabel%3Da1b1%5D%3B%7Dfirst_a0b0-%3Efirst_a0b0%5Blabel%3Daa%5D%3Bfirst_a0b0-%3Efirst_a0b1-%3Efirst_a0b0%5Blabel%3Db%5D%3Bfirst_a1b1-%3Efirst_a0b1-%3Efirst_a1b1%5Blabel%3Da%5D%3Bfirst_a1b1-%3Efirst_a1b1%5Blabel%3Dbb%5D%3Bfirst_a0b0-%3Efirst_a1b1%5Blabel%3Dab%5D%3Bfirst_a1b1-%3Efirst_a0b0%5Blabel%3Dba%5D%3B%7Dsubgraph%20cluster_second%20%7Blabel%3D%22%E6%B6%88%E5%8E%BBa1b1%22%3Bnode%5Bshape%3Ddoublecircle%5D%3Bsecond_a0b0%20second_a0b1%3Bnode%5Bshape%3Dcircle%5D%3Bsecond_a0b0%5Blabel%3Da0b0%5D%3Bsecond_a0b1%5Blabel%3Da0b1%5D%3Bsecond_a0b0-%3Esecond_a0b0%5Blabel%3D%22a%28bb%29%2Aa%22%5D%3Bsecond_a0b1-%3Esecond_a0b1%5Blabel%3D%22a%28bb%29%2Aa%22%5D%3Bsecond_a0b0-%3Esecond_a0b1%5Blabel%3D%22b%7Ca%28bb%29%2Aba%22%5D%3Bsecond_a0b1-%3Esecond_a0b0%3B%7D%7D)，格式化的源码见同目录 [graphviz](./6.gv) 文件，最后很清晰就是

```
S = a(bb)*a
T = b|a(bb)*ba
S*T(S|TT)*
```
### 7）以非正式方式表示的国际象棋步法的集合，如 `p-k4` 或 `kbp×qn`。

不会国际象棋，这题没啥兴趣先跳过，之后有空了再做。

### !! 8）所有由 a 和 b 组成且不包含子串 abb 的串。

换句话说就是，如果出现了一个 `a`，后面最多只能接一个 `b`。

答案是 `b*(a+b?)*`。

### 9）所有由 a 和 b 组成且不含子序列 abb 的串。

子序列的和子串的区别是可以中间跨其它字符。

原题换句话说就是，当出现第一个 `a` 后，后面的串就最多只能出现一个 `b` 了。

答案是 `b*(a+b?a*)?`。

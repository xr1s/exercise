> 从下面的练习开始到联系 3.4.12 介绍了 Aho-Corasick 算法。该算法可以在文本串中识别一组关键字，所需时间和文本长度以及关所有关键字的总长度成正比。该算法使用了一 种成为 *trie* 的特殊形式的状态转换图。Trie 是一个树型结构的状态转换图，从一个节点到它的各个子节点的边上有不同的标号。Trie 的叶子节点表示识别到的关键字。  
> Knuth、Morris 和 Pratt 提出了一种在文本串中识别单个关键字 *b<sub>1</sub>b<sub>2</sub>...b<sub>n</sub>* 的算法。这里的 trie 是一个包含了从 *0 ~ n* 共 *n + 1* 个状态的状态转换图。状态 *0* 是初始状态，状态 *n* 表示接受，也就是发现关键字的情形。从 *0* 到 *n - 1* 之间的任意一个状态 *s* 出发，存在一个标号为 *b<sub>s + 1</sub>* 的到达状态 *s + 1* 的转换。例如，关键字 **ababaa** 的 trie 树为：
> 
> ![](main.svg)
> 
> 为了快速处理文本串并在这些串中搜索一个关键字，针对关键字函数 *b<sub>1</sub>b<sub>2</sub>...b<sub>n</sub>* 以及该关键字中的位置 *s*（对应于关键字的 trie 中的状态 *s*）定义*失效函数 f(s)*，该函数的计算方法如图 3-19 所示。  
> 该函数的目标是使得 *b<sub>1</sub>b<sub>2</sub>...b<sub>f(s)</sub>* 是最长的既是 *b<sub>1</sub>b<sub>2</sub>...b<sub>s</sub>* 的真前缀又是 *b<sub>1</sub>b<sub>2</sub>...b<sub>s</sub>* 的后缀的子串。*f(s)* 之所以重要，原因在于如果我们试图用一个文本串匹配 *b<sub>1</sub>b<sub>2</sub>...b<sub>n</sub>*，并且我们已经匹配了前 *s* 个位置，但此时匹配失败（也就是说文本串的下一个位置并不是 *b<sub>s + 1</sub>*），那么 *f(s)* 就是可能和以我们的当前位置为结尾的文本串相匹配的最长的 *b<sub>1</sub>b<sub>2</sub>...b<sub>n</sub>* 的前缀。当然，文本串的下一个字符必须是 *b<sub>f(s) + 1</sub>*，否则仍然有问题，必须考虑一个更短的前缀，即 *b<sub>f(f(s))</sub>*。  
> ```c++
> t = 0;
> f[1] = 0;
> for (s = 1; s < n; s++) {
>     while (t > 0 && b[s + 1] != b[t + 1]) t = f[t];
>     if (b[s + 1] == b[t + 1]) {
>         t = t + 1;
>         f[s + 1] = t;
>     }
>     else f[s + 1] = 0;
> }
> ```
> <p align="center">图 3-19 计算关键字 *b<sub>1</sub>b<sub>2</sub>...b<sub>n</sub>* 的失效函数的算法</p>
> 看一个例子，根据 `ababaa` 构造的 trie 的失效函数是：
> 
> |   *s*  |1|2|3|4|5|6|
> |--------|-|-|-|-|-|-|
> | *f(s)* |0|0|1|2|3|1|
>
> 例如，状态 3 和 1 分别表示前缀 `aba` 以及 `a`。因为 `a` 是最长的既是 `aba` 的真前缀，同时也是 `aba` 的后缀的串，因此 *f(3) = 1*。同样，因为最长的既是 `ab` 的真前缀又是它的后缀的字符串是空串，因此 *f(2) = 0*。

> 构造下列串的失效函数。
>
> 1）`abababaab`  
> 2）`aaaaaa`  
> 3）`abbaabb`  

1）`abababaab`

|   *s*  |a|b|a|b|a|b|a|a|b|
|--------|-|-|-|-|-|-|-|-|-|
| *f(s)* |0|0|1|2|3|4|5|1|2|

2）`aaaaaa`

|   *s*  |a|a|a|a|a|a|
|--------|-|-|-|-|-|-|
| *f(s)* |0|1|2|3|4|5|

3）`abbaabb`

|   *s*  |a|b|b|a|a|b|b|
|--------|-|-|-|-|-|-|-|
| *f(s)* |0|0|0|1|1|2|3|

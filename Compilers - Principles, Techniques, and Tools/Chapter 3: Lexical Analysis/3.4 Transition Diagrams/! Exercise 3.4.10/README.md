> Aho 和 Corasick 对 KMP 算法进行了推广，使它可以在一个文本串中识别一个关键字集合中的任何关键字。在这种情况下，trie 是一棵真正的树，从其根结点开始就会出现分支。如果一个字符串是某个关键字的前缀（不一定是真前缀），那么在 trie 中就有一个和该字符串对应的状态。串 *b<sub>1</sub>b<sub>2</sub>...b<sub>k - 1</sub>* 对应的状态是串 *b<sub>1</sub>b<sub>2</sub>...b<sub>k</sub>* 对应的状态的父节点。如果一个状态对应于某个完整的关键字，那么该状态就是接受状态。例如，图 3-21 显示了对应于关键字 `he`、`she`、`his` 和 `hers` 的 trie 树。
>
> ![](main.svg)
>
> 通用 trie 树的失效函数定义如下。假设 *s* 是对应于串 *b<sub>1</sub>b<sub>2</sub>...b<sub>n</sub>* 的状态，那么状态 *f(s)* 对应于最长、即是串 *b<sub>1</sub>b<sub>2</sub>...b<sub>n</sub>* 的后缀又是某个关键字的前缀的字符串。例如，图 3-21 中 trie 树的失效函数为：
>
> |  *s* | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
> |:----:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
> |*f(s)*| 0 | 0 | 0 | 1 | 2 | 0 | 3 | 0 | 3 |

> 修改图 3-19 中的算法，使它可以计算通用 trie 树的失效函数。*提示*：主要的不同在于，在图 3-19 的第 4、5 行上，我们不能简单地测试 *b<sub>s + 1</sub>* 和 *b<sub>t + 1</sub>* 是否相等。从任何一个状态出发，都可能存在多个在不同字符上的转换。这些转换都可能进入了代表最长的既是后缀又是前缀的字符串的状态

1. 首先构建一棵 trie 树。
2. 执行广度优先搜索，初始化根的失效指针指向根自己，并把根加入队列。
3. 当队列非空时，从队列中弹出一个节点 `n`。
4. 对于该节点的每个非空孩子 `n->children[k]`，压入队列，创建一个临时指针 `p`，一开始它指向父节点的失效节点 `n->failure`。：
    1. 当 `p` 指向根节点的时候，停止迭代（跳转到第 iv 步）；
    2. 当 `p` 存在非空的和当前孩子 `n->children[k]` 对应的孩子 `p->children[k]` 时，停止迭代；
    3. 否则，使 `p` 指向下一个失效节点 `p->failure`，并继续迭代（跳转到第 i 步）；
    4. 判断 `p->children[k]` 是否存在，若存在则 `n->children[k]` 指向 `p->children[k]`，否则指向 `p`。
4. 直到队列为空为止，重复执行上述步骤。

详见上级目录代码。

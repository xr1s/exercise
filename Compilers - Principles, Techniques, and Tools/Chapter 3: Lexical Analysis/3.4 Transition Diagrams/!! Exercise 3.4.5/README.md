> 说明图 3-19 中第四行的赋值语句 *t = f(t)* 最多被执行 *n* 次。进而说明整个算法的时间复杂度是 *O(n)*，其中 *n* 是关键字的长度。

下面是基于直觉的分析。具体的数值计算要用到势能分析了（参考算法导论），这里就简单说得通就行，偷个懒。

首先显然对任意合法 *k* 值，有 *f(k) < k*，这是根据失败函数的定义可以得到的。

因为 `while` 循环的次数和 *f(t)* 有关，每次 *t* 会变成更小的 *f(t)*，于是就能保证每次进入循环时如果 *t = a*，那就最多只会执行 *f(a)* 次循环。

又因为在执行完一次 `while` 循环后，*t* 都会变小，而且执行多少次迭代就会减少至少多少（有势能分析那味儿了），所以在最差的情况下，*f(s)* 会始终保持一个按 *1* 蓄水，然后最多一次性放水 *f(s)* 次然后继续蓄水的情况。

那么因为长度是 *n*，那么蓄水最多只能蓄到 *n*，那么放水就能放 *n* 次，也就是迭代最多 *n* 次。

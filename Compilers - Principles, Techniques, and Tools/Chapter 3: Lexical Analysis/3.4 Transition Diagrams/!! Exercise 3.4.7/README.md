> 说明图 3-20 中的算法可以正确地指出输入关键字是否为一个给定字符串的子串。*提示*：对 *i* 进行归纳。说明对于所有的 *i*，在第四行运行后 *s* 的值是哪些既是 *a<sub>1</sub>a<sub>2</sub>...a<sub>i</sub>* 的后缀又是该关键字的前缀的字符串中最长字符的长度。

首先需要搞清楚 *s* 的含义，从[练习 3.4.6](../Exercise%203.4.6) 可以推断出来 *s* 的含义其实是已经匹配到的模式串位置。  
也就是说每次执行到第四行的时候 *b<sub>1</sub>b<sub>2</sub>...b<sub>s</sub>* 均已匹配上 *a<sub>1</sub>a<sub>2</sub>...a<sub>i - 1</sub>*。

*i = 1* 的时候，如果 *a<sub>1</sub> = b<sub>1</sub>* 那么 *s = 1*，表示第一个字符匹配上了；否则 *s = 0*，表示第一个字符没匹配上。显然这是满足上面 *s* 的含义的。

然后 `while` 处的归纳逻辑和[练习 3.4.4](../%21%20Exercise%203.4.4) 是完全一样的。最后会得到 *s* 值，就表示到母串 *i - 1* 的位置，模式串退到了哪个位置，如果是 0 则表示完全没匹配上。

然后第四行就表示下一个字符匹配上了则指针右移一位，否则只能是 *s = 0* 的情况退出上行的 `while` 循环。*s* 就又满足条件了。

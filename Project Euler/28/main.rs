// 找规律题, 也很好证; 而且由于数量级极小, 即使模拟也能快速求
//
// 从每个环右上开始逆时针来考虑的话:
// 零环 1 个 1
// 一环 4 次 -2,  等差求和 4*3²-2*4*(4-1)/2
// 二环 4 次 -4,  等差求和 4*5²-4*4*(4-1)/2
// 三环 4 次 -6,  等差求和 4*7²-6*4*(4-1)/2
// 四环 4 次 -8,  等差求和 4*9²-8*4*(4-1)/2
// 五环 4 次 -10, 等差求和 4*11²-10*4*(4-1)/2
// 以此类推, k 环是 4(2k+1)²-12k=4(4k²+k+1)
// 全部求和, 也可以直接推导公式出来 16n³/3+10n²+26n/3
// 1001 阶矩阵有 500 环, 所以答案呼之欲出

fn solve(n: i64) -> i64 {
    assert!(n % 2 == 1);
    let k = n / 2;
    return (16 * k * k + 30 * k + 26) * k / 3 + 1;
}

fn main() {
    println!("{}", solve(1001));
}
